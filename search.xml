<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>接口层防护</title>
      <link href="/2019/01/25/%E6%8E%A5%E5%8F%A3%E5%B1%82%E9%98%B2%E6%8A%A4/"/>
      <url>/2019/01/25/%E6%8E%A5%E5%8F%A3%E5%B1%82%E9%98%B2%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="当前问题"><a href="#当前问题" class="headerlink" title="当前问题"></a>当前问题</h4><ol><li>前一个请求未结束，新的请求发起了，两次请求参数一致，结果一致，第二个请求没有必要发起。例如用户短时间内连续点击按钮触发请求的情况</li><li>前一个请求未结束，新的请求发起了，两次请求参数不一致，结果不一致，应使用第二次请求的结果，但第一次请求的响应比第二次请求的响应要晚，导致呈现在页面中的是第一次的结果（<strong>这里请求的发起来自同一个地方/组件。假设页面中有A组件和B组件，它们对同一个接口发起参数不同的请求，就不需要考虑这问题</strong>）</li></ol><h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>无论是使用原生的XHR还是第三方AJAX函数，加一层自己的封装，考虑如下几种方案</p><h5 id="加延时"><a href="#加延时" class="headerlink" title="加延时"></a>加延时</h5><p>点击一次按钮后，加一个100毫秒的setTimeout延时，如果这期间内用户又点击按钮了，会clearTimeout清除掉，前一个按钮发起的请求不会真正发起。这是接口层防护，禁用按钮交互体验更好，但需要改动UI层</p><p>问题：请求来自多个组件时不能忽略任何一个请求</p><h5 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a><strong>合并请求</strong></h5><p>检查URL和参数是否一致，如果一致，第二次发起的请求不会真正的发起，等待第一次请求的结果，并返回</p><h5 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h5><p>检查URL和参数是否一致，如果不一致，abort掉前一个请求，等待第二次请求的结果，并返回<br>问题：但是接口层无法知道请求的发起来自一个还是多个组件，多个组件不能abort，所以并不适用</p><h5 id="响应顺序保证"><a href="#响应顺序保证" class="headerlink" title="响应顺序保证"></a><strong>响应顺序保证</strong></h5><p>检查URL和参数是否一致，如果不一致，且第二次请求结果先返回，收集结果，等待第一次请求的结果也返回后，按顺序返回给上层业务</p><p>这种方式也会有小问题：可能会导致页面的呈现变慢，如A组件和B组件是隔离的，但一定要等待两个请求都返回结果后才能渲染页面</p><p>综上，在接口层可以增加<strong><em>合并请求</em></strong>和<strong><em>响应顺序保证</em></strong>两项防护</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>Promise作为异步编程的一种解决方案，能很简单的实现<strong><em>合并请求</em></strong>和<strong><em>响应顺序保证</em></strong></p><ul><li><p>合并请求时，第二个请求等待并使用第一个请求的结果；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = api1().then(callback1)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(callback2)</span><br></pre></td></tr></table></figure></li><li><p>保证响应顺序时，第二个请求无论结果返回与否都需要等待第一个请求结束</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = api1().then(callback1)</span><br><span class="line"><span class="keyword">let</span> p2 = api2().then(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">Promise</span>.all([p1])).then(callback2) <span class="comment">// 等价 api2().then(_ =&gt; p1).then(callback2)</span></span><br><span class="line"><span class="keyword">let</span> p3 = api3().then(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">Promise</span>.all([p1, p2])).then(callback3) <span class="comment">// 等价 api3().then(_ =&gt; p2).then(callback3)</span></span><br></pre></td></tr></table></figure></li></ul><!-- [测试Demo]() -->]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>认识Vue项目——响应式数据系统</title>
      <link href="/2018/12/21/%E8%AE%A4%E8%AF%86Vue%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/12/21/%E8%AE%A4%E8%AF%86Vue%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="一句话描述"><a href="#一句话描述" class="headerlink" title="一句话描述"></a>一句话描述</h1><p>首先当前需要收集的依赖（所谓依赖就是Watcher对象，有唯一ID，回调函数等）会存储在Dep.target这个唯一变量中。<br>对于对象，定义每一个属性的getter/setter，通过闭包引用一个依赖收集器（Dep对象），在getter中判断Dep.target是否不为空，是则收集依赖到收集器中，之后在setter中触发收集器中的依赖<br>对于数组，拦截变异方法以便在修改数组时触发收集器中的依赖，然后循环处理每一个元素，如果元素是对象或数组，就递归定义该元素的响应式</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>要成为响应式数据必须是对象或者数组<br>以对象为例，遍历对象的每一个属性，通过<strong>Object.definePropery</strong>定义属性的getter/setter，如果属性的值为对象/数组，则递归处理后。最终会生成一个Observer实例对象，并挂载在对象的__ob__属性中</p><ul><li>getter：收集依赖并返回值</li><li>setter：设置值并触发依赖</li></ul><p>初始化后的数据结构如下</p><img src="/2018/12/21/认识Vue项目——响应式数据系统/asset-2.png"><p>Dep2和Dep3存储的依赖相同，只是触发时机不同</p><ul><li>Dep2: 属性的值为对象，在对象上添加/删除($set,$del)属性时触发；属性的值为数组，在数组上添加/删除(push,pop等)元素时触发</li><li>Dep3: 修改属性的值时触发其中的依赖</li></ul><p>这只是初始化的工作，此时并没有依赖被收集到属性的Dep实例中。真正的依赖收集需要调用$watch方法</p><h1 id="收集依赖"><a href="#收集依赖" class="headerlink" title="收集依赖"></a>收集依赖</h1><p>以一个简单的例子为例，监听pro的值，一旦改变则调用callback<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unwatchFn = vm.$watch(<span class="string">'pro'</span>, callback, options)</span><br></pre></td></tr></table></figure></p><p>$watch的调用创建了Watcher对象，并返回用于取消继续监听的函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, <span class="string">'pro'</span>, callback, options)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  watcher.teardown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建Watcher对象的过程主要做了以下几件事</p><ol><li><p>属性赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">watcher.getter：取值函数，从vm中取到pro的值（不是拦截器getter）</span><br><span class="line">watcher.cb：回调函数callback</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>将唯一变量Dep.target设置为当前创建的Watcher对象</p></li><li>通过该Watcher对象的取值函数访问pro的值。pro已经经过响应式系统初始化后被定义了getter拦截器，因此访问pro时被getter拦截，从而收集当前Dep.target中的依赖<img src="/2018/12/21/认识Vue项目——响应式数据系统/asset-3.png">对每一个属性求值意味着当前Dep.target也会被添加到每一个属性自己的Dep实例中，实现深度检测</li><li>恢复Dep.target原来的值</li></ol><p>定义在watch选项上的监听，也是调用$watch来创建Watcher对象的</p><p>这种$watch方法创建的Watcher叫做自定义观察者。除此之外还有渲染函数观察者和计算属性观察者</p><h1 id="数组响应式"><a href="#数组响应式" class="headerlink" title="数组响应式"></a>数组响应式</h1><p><strong>数组的索引是非响应式的</strong>，所以不能对索引值0，1，2…等定义其getter/setter，因此也就不能通过数组索引改变元素的值而触发依赖，只能拦截变异方法</p><p>变异方法指的是如push、pop、shift、unshift、splice、sort 以及 reverse 等会改变自身的值的方法。这里的改变只涉及增加元素、删除元素 以及变更元素顺序。还有替换元素，但它可以理解为删除和增加的复合操作</p><p>拦截变异方法<br>覆盖<strong>数组实例</strong>的__proto__，指向一个新的对象，在该对象上定义了同名的变异方法，同时把该对象的__proto__指向Array.prototype。对于不支持__proto__的浏览器，则直接在数组实例上覆盖了变异方法</p><ol><li>调用原始的变异方法得到新值</li><li>如果为新增操作，对新增的元素做响应式处理</li><li>调用<strong>ob</strong>.dep.notify()触发依赖（也会触发重新求值该数组，重新收集依赖）</li><li>返回第一步得到的新值</li></ol><p></p><p></p><br><img src="/2018/12/21/认识Vue项目——响应式数据系统/asset-4.png"><p></p><p>由于不能给第一个元素Tom设置getter/setter，也就没有对应的Dep实例用于存储依赖，所以和上面的对象相比少了Dep1<br><code>pro[0]=&quot;Jerry&quot;</code>无法触发依赖<br><code>pro.splice(0, 1, &quot;Jerry&quot;)</code>可以触发依赖</p><p><small>同样的，我们已经知道，Dep2和Dep3存储的依赖是相同的，只是触发时机不同</small></p><p>一个更复杂的例子<br><img src="/2018/12/21/认识Vue项目——响应式数据系统/asset-5.png"><br>不同的地方在于数组中的元素为对象时，依赖也会被收集到元素自身的__ob__.dep(即图中的Dep2，注意Dep2的触发时机只在增加/删除属性时)中，不论options.deep是true还是false<br>在给该元素<strong>增加/删除属性</strong>时，也认为数组改变了，需要触发依赖，所以元素自身的__ob__.dep才需要收集</p><p>下面代码会触发依赖调用callback<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$set(pro[<span class="number">0</span>], <span class="string">'age'</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure></p><h1 id="渲染函数观察者"><a href="#渲染函数观察者" class="headerlink" title="渲染函数观察者"></a>渲染函数观察者</h1><p>如果没有定义render选项，则template中定义的模板字符串会被编译为渲染函数，并将渲染函数赋值给 vm.$options.render 选项</p><p>挂载元素时（mounted钩子之前），会创建一个Watcher对象，用于在数据改变时触发重新渲染，这个Watcher对象就叫渲染函数观察者<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop, options, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p><ul><li>updateComponent: 函数，调用 render 函数并返回生成的虚拟节点(vnode)，然后虚拟节点渲染成真正的 DOM。<strong>又因为渲染函数的执行会触发数据属性的 get 拦截器函数，从而将依赖(该渲染函数观察者)收集</strong></li><li>noop: 空函数，值改变时触发的回调不做任何事</li><li>options: 其他选项，用于触发beforeUpdate钩子</li><li>true：一个Boolean，true，表明当前创建的是渲染函数观察者</li></ul><p><strong>Watcher构造函数的第二个参数代表的是如何从vm取值，如果是函数则在vm下执行，如果是字符串则从vm取得该属性值。并且在值发生变化时重新取值，这也是为什么创建渲染函数观察者时传入noop回调，而仍然能重新渲染，就是因为updateComponent会再次执行</strong></p><p>Watcher实现了避免收集重复依赖的机制，所以重复执行updateComponent并不会导致重复收集依赖</p><h1 id="计算属性观察者"><a href="#计算属性观察者" class="headerlink" title="计算属性观察者"></a>计算属性观察者</h1><p>每一个计算属性都会创建一个对应的计算属性观察者，并且在vm实例上挂载时会定义getter/setter，在getter中访问对应的计算属性观察者，通过观察者对其进行求值并收集依赖，然后返回结果</p><ol><li>取得计算属性的观察者</li><li>判断是否需要重新求值，是则求值，不是则使用上一次求得的结果</li><li>判断Dep.target是否不为空，是则收集依赖</li><li>返回值</li></ol><p>注意，在自定义观察者创建时会触发一次求值，但是计算属性观察者是惰性求值的，只有在真正访问时计算属性时，才会致使数据属性收集计算属性观察者</p><p>创建计算属性观察者<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(vm, getter || noop, noop, computedWatcherOptions)</span><br></pre></td></tr></table></figure></p><ul><li>getter: 函数，用户定义的计算属性的取值函数</li><li>noop: 空函数，值改变时触发的回调不做任何事</li><li>computedWatcherOptions: computedWatcherOptions.lazy为true，表明当前创建的是计算属性观察者</li></ul><p>计算属性的getter<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key] <span class="comment">// _computedWatchers存储所有计算属性观察者</span></span><br><span class="line"><span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">  <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">    watcher.evaluate() <span class="comment">// 该方法只有计算属性观察者会调用，使数据属性收集计算属性观察者</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    watcher.depend() <span class="comment">// 该方法只有计算属性观察者会调用，收集渲染函数观察者到数据属性的依赖框中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> watcher.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dep和Watcher互相引用<br><img src="/2018/12/21/认识Vue项目——响应式数据系统/asset-6.png"><br>Dep和Watcher为多对多的关系，并且互相引用，Dep的subs属性存储所有的Watcher，Watcher的deps属性存储所有的Dep</p><p>实现机制<br>首先数据属性收集计算属性观察者，然后借助计算属性观察者收集渲染函数观察者到它deps中存储的所有依赖框中，也就是数据属性引用的依赖框中，因此数据属性的改变，不仅能触发计算属性观察者的更新，也能触发渲染函数观察者的更新</p><h1 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h1><p>假如同时修改很多属性的值，每个属性值的改变都要触发重新渲染，就会导致性能问题，因此通过异步更新达到优化的目的</p><p>实现机制<br>内部维护了一个唯一队列，当修改属性的值之后，将需要执行更新操作的观察者加入队列，添加时会判断队列中是否已存在当前观察者，然后通过nextTick创建一个任务，等到下一次事件循环时，一次性的执行队列中所有观察者的更新方法，并清空队列；而在执行之前，可以继续添加观察者到队列中，但此时不会再调用nextTick创建任务</p><p>nextTick本身内部也维护了一个唯一队列，用于存储回调函数。创建任务时优先创建微任务，如果不支持者则降级为宏任务。关于微任务，宏任务，事件循环<a href="http://yyzych.github.io/2018/12/08/Javascript%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%E2%80%94%E2%80%94%E8%BF%99%E4%B8%80%E6%AC%A1%E5%81%9A%E5%88%B0%E5%BF%83%E4%B8%AD%E6%9C%89%E6%95%B0/">请看这里</a></p><p>Watcher的update方法。除非指定为同步更新，否则将该观察者通过queueWatcher函数添加到队列中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  if (this.lazy) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if (this.sync) &#123;</span><br><span class="line">    this.run()</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    queueWatcher(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>queueWatcher函数。刷新队列的行为在flushSchedulerQueue函数中执行，它将传递给nextTick以在下一次事件循环中执行</p><ul><li>flushing: 判断是否正在执行更新操作</li><li>waiting: 判断是否已创建了一次刷新队列的任务</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line">      ...</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>阅读Vue源码时的注释写在<a href="https://github.com/yyzych/vue/tree/comment" target="_blank" rel="noopener">仓库</a>中，响应式的代码在<a href="https://github.com/yyzych/vue/tree/comment/src/core/observer" target="_blank" rel="noopener">observer/</a>目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">observer/</span><br><span class="line">    array.js        处理数组响应式的代码</span><br><span class="line">    dep.js.         存储依赖的对象。依赖为Watcher对象</span><br><span class="line">    index.js.       定义了Observer对象及defineReactive函数，defineReactive函数处理对象属性的getter,setter。入口文件</span><br><span class="line">    scheduler.js    维护了一个队列，所有变更推入队列，在一次事件循环中统一执行</span><br><span class="line">    traverse.js     递归处理响应式属性时要防止循环引用的死循环问题</span><br><span class="line">    watcher.js      定义Watcher对象。收集依赖，执行依赖</span><br></pre></td></tr></table></figure></p><p>其他参考资料<br><a href="http://hcysun.me/vue-design/art/7vue-reactive.html" target="_blank" rel="noopener">揭开数据响应系统的面纱</a><br><a href="http://hcysun.me/vue-design/art/8vue-reactive-dep-watch.html" target="_blank" rel="noopener">渲染函数的观察者与进阶的数据响应系统</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 响应式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Javascript执行之大揭秘——这一次做到心中有数</title>
      <link href="/2018/12/08/Javascript%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%E2%80%94%E2%80%94%E8%BF%99%E4%B8%80%E6%AC%A1%E5%81%9A%E5%88%B0%E5%BF%83%E4%B8%AD%E6%9C%89%E6%95%B0/"/>
      <url>/2018/12/08/Javascript%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%E2%80%94%E2%80%94%E8%BF%99%E4%B8%80%E6%AC%A1%E5%81%9A%E5%88%B0%E5%BF%83%E4%B8%AD%E6%9C%89%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="单线程执行"><a href="#单线程执行" class="headerlink" title="单线程执行"></a>单线程执行</h1><p>Javascript语言本身来说没有单线程的概念和机制，单线程指的是Javascript程序的执行是单线程的</p><p>执行环境如浏览器，Node等，它们的环境中带有JavaScript引擎，是专门处理JavaScript脚本的虚拟机。Javascript程序跑在引擎之上，且引擎以单线程的方式执行Javascript程序。<br><small>多线程需要共享资源，对最开始设计之初只是用来处理简单任务的网页脚本语言来说太复杂了，可能因此才会设计为单线程执行</small></p><p>而浏览器，Node等本身是多线程执行的，因为除了Javascript引擎外，还有其他的线程在工作，包括界面渲染线程，浏览器事件触发线程，Http请求线程</p><p><strong>除开H5引入的Web Worker来说，以上的描述没有问题。但是Web Worker的出现，允许我们在主线程之外开一些工作线程来处理耗时任务</strong></p><h1 id="认识异步模式"><a href="#认识异步模式" class="headerlink" title="认识异步模式"></a>认识异步模式</h1><p>运行以后的程序叫做进程，一般情况下一个进程一次只能执行一个任务。程序可能会有很多的任务需要处理，这时有3种处理方式选择<br><blockquote><ol><li>排队。因为一个进程一次只能执行一个任务，只好等前面的任务执行完了，再执行后面的任务</li><li>新建进程。使用fork命令，为每个任务新建一个进程。</li><li>新建线程。因为进程太耗费资源，所以如今的程序往往允许一个进程包含多个线程，由线程去完成任务</li></ol><footer><strong>http://www.ruanyifeng.com/blog/2013/10/event_loop.html</strong></footer></blockquote></p><p>因为JavaScript程序是单线程执行的，所有任务都在一个线程上完成，所有任务都是排队处理，一旦遇到大量任务或一个耗时的任务，网页就会出现“假死”，无法响应用户行为。这种排队处理的运行方式也叫“同步模式”或”堵塞模式“<br><img src="http://www.ruanyifeng.com/blogimg/asset/201310/2013102002.png"><br>特别是像I/O操作这种，是很耗时的，花费了大量的时间花在等待中。因此，如果能在I/O等指令发送之后继续执行队列中的后面任务，等I/O完成后再回过头来处理该I/O的响应，如此就能节省大量资源和执行时间<br><img src="http://www.ruanyifeng.com/blogimg/asset/201310/2013102004.png" alt=""><br>这种运行方式称为”异步模式”或”非堵塞模式”</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>图示（转自<a href="https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec" target="_blank" rel="noopener">《Understanding Javascript Function Executions — Call Stack, Event Loop , Tasks &amp; more》</a>）</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*-MMBHKy_ZxCrouecRqvsBg.png" alt=""></p><p>理解这张图需要先理解以下几个概念，由于每个概念深入下去又有很多可以讨论的问题，这里只简单介绍一下</p><h2 id="执行上下文-Execution-Context"><a href="#执行上下文-Execution-Context" class="headerlink" title="执行上下文(Execution Context)"></a>执行上下文(Execution Context)</h2><p>理解为代码运行时的环境，环境意味着当前能访问到哪些变量，哪些函数，this指向等，是一个抽象概念</p><p>三种执行上下文</p><ul><li>全局执行上下文。默认的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li>函数执行上下文。每当一个函数被调用时, 都会为该函数创建一个新的上下文。</li><li>Eval函数执行上下文。在Eval 函数内部执行的代码有属于它自己的执行上下文。</li></ul><p>创建执行上下文的细节</p><ol><li>创建阶段<ol><li>求this的值。由如何调用决定</li><li>创建词法环境组件 （构建作用域链；存储ES6中使用let, const声明的变量和声明式的函数）</li><li>创建变量环境组件（存储使用var声明的变量。可以简单认为是变量对象）</li></ol></li><li>执行阶段<br> 解释/执行代码。执行到每一行变量声明的位置时，才真正的对改变量进行赋值<br> <strong>注意：创建阶段变量（不包括声明式的函数，函数存在声明提升）并没有赋值，let, const声明的变量赋值前使用会报错，var声明的变量会返回undefined</strong></li></ol><p>变量对象（VO），活动对象（AO）<br>活动对象其实就是被激活的变量对象。每进入一个执行上下文时，这个执行上下文儿中的变量对象就被激活</p><h2 id="函数调用栈-Call-Stack"><a href="#函数调用栈-Call-Stack" class="headerlink" title="函数调用栈(Call Stack)"></a>函数调用栈(Call Stack)</h2><p>调用栈其实是一种解析器去处理程序的机制，能根据它追踪方法的调用和状态。上图的stack就是调用栈。栈这种数据结构的特点就是：后进先出</p><ol><li>栈底永远是全局执行上下文，栈顶就是当前正在执行的上下文</li><li>一个函数被调用的时候会将该函数的执行上下文推入栈顶</li><li>任何被这个函数调用的函数会进一步添加到调用栈中，执行结束后退出调用栈，程序运行到它们被上个函数调用的位置</li><li>当执行完这个函数后，它也从调用栈中推出，程序运行到它自己被上个函数调用的位置</li></ol><p><img src="https://img.ctolib.com/uploadImg/20170926/20170926143645_214.jpg" alt=""></p><p style="text-align: center; font-size: 0.7em;">示意图少了栈底全局执行上下文</p><p><small>其实栈中维护的是<a href="https://juejin.im/post/5b1560afe51d4506a74d2aeb" target="_blank" rel="noopener">栈帧</a>，栈帧中才维护了函数调用的上下文以及函数的返回地址，参数，局部变量等内容</small></p><h2 id="堆（Heap"><a href="#堆（Heap" class="headerlink" title="堆（Heap)"></a>堆（Heap)</h2><p>以堆的数据结构形式来存储数据的内存空间。上一节知道，调用栈中的每一帧中也维护了变量，参数，所以栈也是能存储一些数据。区别在于：<br>数据结构不同：<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D" target="_blank" rel="noopener">堆结构</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">栈结构</a><br>主要用途不同：堆主要用来存放对象的，栈主要用来执行程序以及存储一些简单类型的数据</p><ul><li>基本类型 （Undefined、Null、Boolean、Number和String）<br>  基本类型在内存中占据空间小、大小固定 ，他们的值保存在栈(stack)空间，是按值来访问</li><li>引用类型 （对象、数组、函数）<br>  引用类型占据空间大、大小不固定, 栈内存中存放地址指向堆(heap)内存中的对象。是按引用访问的</li></ul><p><img src="https://files.jb51.net/file_images/article/201805/2018527838001.png" alt=""></p><h2 id="任务队列-Call-Queue"><a href="#任务队列-Call-Queue" class="headerlink" title="任务队列(Call Queue)"></a>任务队列(Call Queue)</h2><p>异步任务的回调函数会进入任务队列之中。一旦调用栈中的任务执行完成后，就会去执行任务队列之中的任务</p><p>对DOM的操作有同步与异步之分<br>调用setAttribute，设置style等是在同步执行的，因此在使用这些方法，会导致重排重绘<br>交互产生的事件或addEventListener触发的事件是异步的，浏览器会将回调函数注册到任务队列之中</p><p>不只一个任务队列<br>不同任务源的回调函数会被放进不同的任务队列里面。DOM事件的回调函数进入DOM的任务队列，setTimeout的回调函数被进入setTimeout的任务队列之中，Promise的回调函数（传给then, catch的方法）进入Promise的任务队列等</p><p><strong>注意：Promise的第一个参数是不会进Promise的任务队列的，而是直接进调用栈执行</strong></p><p>其中setTimeout, setInterval的任务队列中的任务叫做macro-task(宏任务)，Promise的任务队列中的任务叫micro-task(微任务)。具体分为</p><ul><li>macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate(Node API), I/O, UI rendering</li><li>micro-task包括：process.nextTick(Node API), 原生Promise, Object.observe, MutationObserver</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果已经了解了以上所介绍的这些铺垫，那么事件循环的机制已经呼之欲出了</p><p>事件循环的顺序是从script开始第一次循环，随后全局上下文进入函数调用栈，碰到macro-task就将其交给处理它的模块处理完之后将回调函数放进macro-task的队列之中，碰到micro-task也是将其回调函数放进micro-task的队列之中。直到函数调用栈清空只剩全局执行上下文，然后开始执行所有的micro-task。当所有可执行的micro-task执行完毕之后。执行macro-task中的一个任务队列，执行完之后再执行所有的micro-task，就这样一直循环。</p><p><small>代码都要在调用栈执行。上图中指定的WEB APIS，无论是它本身还是它的回调函数都要进调用栈执行</small></p><p>两个具体的例子<br><a href="https://zhuanlan.zhihu.com/p/26229293" target="_blank" rel="noopener">深入浅出Javascript事件循环机制(上)</a><br><a href="https://zhuanlan.zhihu.com/p/26238030" target="_blank" rel="noopener">深入浅出JavaScript事件循环机制(下)</a></p><p>其他参考资料<br><a href="https://www.zhihu.com/question/35905242" target="_blank" rel="noopener">javascript既然是单线程语言 ， 为什么会分主线程和消息线程(event loop) ?</a><br><a href="https://juejin.im/post/5ba32171f265da0ab719a6d7" target="_blank" rel="noopener">[译] 理解 JavaScript 中的执行上下文和执行栈</a><br><a href="https://segmentfault.com/a/1190000009041008" target="_blank" rel="noopener">深入理解JavaScript执行上下文、函数堆栈、提升的概念</a><br><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html" target="_blank" rel="noopener">什么是 Event Loop？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 单线程 </tag>
            
            <tag> 事件循环 </tag>
            
            <tag> 执行上下文 </tag>
            
            <tag> 调用栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Webpack HMR</title>
      <link href="/2018/11/10/Webpack-HMR/"/>
      <url>/2018/11/10/Webpack-HMR/</url>
      
        <content type="html"><![CDATA[<p>早些项目用的是Webpack1，配合webpack-dev-server，还算简单的配置就可实现热加载。这次接手的项目用了Webpack2，以及有两点不同导致配置更加复杂</p><ul><li>项目有自己的Node服务所以没有通过webpack-dev-server另起静态服务器</li><li>多个构建目标</li></ul><p>Webpack的配置实在让人头大（其实还是自己没有熟读文档），尤其是热加载这块。针对这次的项目做一个总结</p><h3 id="热刷新与热加载"><a href="#热刷新与热加载" class="headerlink" title="热刷新与热加载"></a>热刷新与热加载</h3><blockquote><ul><li>热刷新：文件改动后，整个页面刷新，不保留任何状态（比如输入过内容的Input表单），相当于webpack帮你摁了F5刷新</li><li>热加载：文件改动后，以最小的代价改变被改变的区域。尽可能保留改动文件前的状态（对input输入内容后，修改其他标签的代码）。即HMR</li></ul></blockquote><h3 id="编译代码的方式"><a href="#编译代码的方式" class="headerlink" title="编译代码的方式"></a>编译代码的方式</h3><p>开发时，要将原始代码编译为在浏览器中可执行的代码，最原始的，每一次改动后，人肉执行编译命令生成新文件。但是，大清都忘了多少年，这种方式效率太低了，无脑重复的事就应该交给机器去做。Webpack提供3种编译的方案选择，提高开发阶段的工作效率</p><h4 id="webpack’s-Watch-Mode"><a href="#webpack’s-Watch-Mode" class="headerlink" title="webpack’s Watch Mode"></a>webpack’s Watch Mode</h4><p>观察模式。如果其中一个文件被更新，代码将被重新编译，所以你不必手动运行整个构建。但是你还是需要手动刷新浏览器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --watch</span><br></pre></td></tr></table></figure></p><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>提供了一个简单的web服务器。文件改动后，web服务器就会自动重新加载编译后的代码，省掉了手动刷新浏览器这一步。同时支持热刷新和热加载<br>简单的使用，只需要在webpack配置文件中添加devServer一节<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">entry: &#123;</span><br><span class="line">  app: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 告诉 webpack-dev-server，在 localhost:8080 下建立服务</span></span><br><span class="line">devServer: &#123;</span><br><span class="line">  <span class="comment">// 服务的根目录在dist 目录下</span></span><br><span class="line">  contentBase: <span class="string">'./dist'</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="webpack-dev-middleware"><a href="#webpack-dev-middleware" class="headerlink" title="webpack-dev-middleware"></a>webpack-dev-middleware</h4><p>中间件。它可以把<strong><em>webpack处理后的文件传递给一个服务器(server)</em></strong>。 webpack-dev-server 在内部使用了它，同时，它也可以作为一个单独的包来使用，以便进行更多自定义设置来实现更多的需求。比如你有一个自己的Node服务<br>webpack.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">entry: &#123;</span><br><span class="line">  app: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  publicPath: <span class="string">'/'</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>server.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config);</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  <span class="comment">// 如何访问编译后的静态资源</span></span><br><span class="line">  <span class="comment">// 如果配置为'/'，则表示资源在http://localhost:3000 下访问。注意，是在当前Node服务的端口之下</span></span><br><span class="line">  publicPath: config.output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!\n'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="启用HMR"><a href="#启用HMR" class="headerlink" title="启用HMR"></a>启用HMR</h3><p>上面的编译方式中第二，三种方式都支持热刷新和热加载。启用热加载还需要多做一些工作</p><h4 id="webpack-dev-server-1"><a href="#webpack-dev-server-1" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>修改webpack配置文件devServer一节中的配置，再配合使用webpack内置的HMR插件即可<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">entry: &#123;</span><br><span class="line">  app: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 告诉 webpack-dev-server，在 localhost:8080 下建立服务</span></span><br><span class="line">devServer: &#123;</span><br><span class="line">  <span class="comment">// 服务的根目录在dist 目录下</span></span><br><span class="line">  contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">  <span class="comment">// 启用webpack的模块热替换特性</span></span><br><span class="line">  hot: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 使用HotModuleReplacementPlugin后才能完全启用HMR</span></span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  <span class="comment">// 可选。当接收到热更新信号时，在浏览器console控制台打印更多可读性高的模块名称等信息</span></span><br><span class="line">  <span class="keyword">new</span> webpack.NamedModulesPlugin()</span><br><span class="line">],</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><blockquote><p>注意，必须有 webpack.HotModuleReplacementPlugin 才能完全启用 HMR。如果 webpack 或 webpack-dev-server 是通过 –hot 选项启动的，那么这个插件会被自动添加，所以你可能不需要把它添加到 webpack.config.js 中。</p><footer><strong>@webpack</strong><cite><a href="https://webpack.docschina.org/configuration/dev-server/#devserver-hot" target="_blank" rel="noopener">webpack.docschina.org/configuration/dev-server/#devserver-hot</a></cite></footer></blockquote><p>修改入口文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 HotModuleReplacementPlugin 启用了HMR后，它的接口将被暴露在 module.hot 属性下面。需要先要检查这个接口是否可访问，然后再开始使用它。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="comment">// 指定的依赖模块发生改变时进行更新，更新完成后触发回调</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./print.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Accepting the updated printMe module!'</span>);</span><br><span class="line">    printMe();</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 或者也可以</span></span><br><span class="line">  <span class="comment">// 接受自身更新。当前模块或依赖模块发生改变时进行更新</span></span><br><span class="line">  <span class="comment">// 在入口文件中添加，则意味对所有模块的修改都能监听到并进行更新</span></span><br><span class="line">  <span class="comment">// module.hot.accept(</span></span><br><span class="line">  <span class="comment">//   errorHandler // 更新异常时触发错误回调</span></span><br><span class="line">  <span class="comment">// );</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://webpack.docschina.org/guides/hot-module-replacement#%E5%90%AF%E7%94%A8-hmr" target="_blank" rel="noopener">完整的官方示例</a></p><p>上面是通过配置的方式使用webpack-dev-server，其实也可以通过webpack-dev-server提供的<a href="https://webpack.docschina.org/guides/hot-module-replacement#%E9%80%9A%E8%BF%87-node-js-api" target="_blank" rel="noopener">Node.js API</a>方式使用<br>注意，它与下面的webpack-dev-middleware不是一回事，虽然都有一个自己的Node服务，但是webpack-dev-server会另起一个静态文件服务（内部也调用了webpack-dev-middleware），而webpack-dev-middleware则以中间件的形式将处理结果通知给自己的Node服务</p><h4 id="webpack-dev-middleware-1"><a href="#webpack-dev-middleware-1" class="headerlink" title="webpack-dev-middleware"></a>webpack-dev-middleware</h4><p>配合<a href="https://github.com/webpack-contrib/webpack-hot-middleware" target="_blank" rel="noopener">webpack-hot-middleware</a>才能在自己的服务下启用 HMR<br>webpack.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">entry: &#123;</span><br><span class="line">  app: [</span><br><span class="line">    <span class="comment">// 用于连接后台服务，接受后台服务修改编译文件后的通知</span></span><br><span class="line">    <span class="comment">// 通过查询字符串传递参数</span></span><br><span class="line">    <span class="string">'webpack-hot-middleware/client'</span>,</span><br><span class="line">    <span class="string">'./src/index.js'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  publicPath: <span class="string">'/'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 不再需要devServer一节</span></span><br><span class="line">plugins: [</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 仍然需要使用HotModuleReplacementPlugin</span></span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  <span class="keyword">new</span> webpack.NamedModulesPlugin()</span><br><span class="line">],</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>server.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackHotMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config);</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  publicPath: config.output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// 加入webpack-hot-middleware中间件</span></span><br><span class="line"><span class="comment">// 可传入webpack-hot-middleware的配置项作为第二个参数</span></span><br><span class="line">app.use(webpackHotMiddleware(compiler));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!\n'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>入口文件也需要调用module.hot.accept，webpack-dev-server方式一模一样。略去</p><p>传给客户端的配置。可以通过查询字符串的方式传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-hot-middleware/client?noInfo=true&amp;path=/__webpack_hmr__</span><br></pre></td></tr></table></figure></p><ul><li>path - 中间件为事件流提供的路径。相当于消息是通过这个地址从后台传给客户端的</li><li>name - 捆绑名称，专门用于多编译器模式。2.13.0之前不支持多编译器模式</li><li>timeout - 尝试重新连接后断开连接后等待的时间</li><li>reload - 设置为true在Webpack卡住时自动重新加载页面</li><li>noInfo - 设置为true禁用信息（Info级别的日志？）控制台日志记录</li><li>quiet - 设置为true禁用所有控制台日志记录</li><li>dynamicPublicPath</li><li>autoConnect</li></ul><p>传给中间件的配置。通过传递第二个参数传递<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">webpackHotMiddleware(compiler, &#123;</span><br><span class="line">  log: <span class="literal">false</span>,</span><br><span class="line">  path: <span class="string">"/__webpack_hmr__"</span>,</span><br><span class="line">  heartbeat: <span class="number">2000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>log - 用于记录行的函数，传递false到禁用。默认为console.log</li><li>path - 中间件服务的事件流的路径必须与客户端设置相匹配</li><li>heartbeat - 多长时间将心跳更新发送到客户端以保持连接的活动。应小于客户的timeout设置 - - 通常设置为其一半值</li></ul><h3 id="多个构建目标"><a href="#多个构建目标" class="headerlink" title="多个构建目标"></a>多个构建目标</h3><p>除了导出一个配置对象外，webpack.config.js也支持导出<a href="https://webpack.docschina.org/configuration/configuration-types" target="_blank" rel="noopener">函数，Promise, 多个配置对象</a></p><p>以我的实际情况为例，我接手的项目</p><ul><li>会启动一个node服务</li><li>同时有移动端和桌面端的代码</li><li>静态文件服务的根目录为public/，构建后输出文件都在public/之下</li><li>使用webpack-dev-middle实现热加载机制</li></ul><p>考虑单独构建mobile, desktop<br>调用不同的webpack配置文件或一个配置文件中通过环境变量控制当前构建哪一个。麻烦的点在于不能同时构建，如果正开发着移动端，突然要切换到桌面端则需要重启。代码里少不了到处判断当前构建目标是哪个了。有没有更简单的方式？</p><p>考虑使用多个entry的方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  mobile: <span class="string">'src/mobile/index.js'</span>,</span><br><span class="line">  desktop: <span class="string">'src/desktop/index.js'</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.join(__dirname, <span class="string">'public/'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'@'</span>: path.join(__dirname, <span class="string">'src'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>但是这样会有一个问题，mobile和desktop的源文件位于不同的目录之下，假设都用@作为别名指向src/目录并不太方便，import时还必须加上<strong><em>“@/mobile”</em></strong>,<strong><em>“@/desktop”</em></strong>，变通的方式是再找一个符号区别mobile和desktop<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  mobile: <span class="string">'src/mobile/index.js'</span>,</span><br><span class="line">  desktop: <span class="string">'src/desktop/index.js'</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.join(__dirname, <span class="string">'public/'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'@'</span>: path.join(__dirname, <span class="string">'src/desktop'</span>),</span><br><span class="line">    <span class="string">'_'</span>: path.join(__dirname, <span class="string">'src/mobile'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>不是不可以，只是项目已有一定规模，不希望重改。并且还有一个问题是，这种方式只能指定一个Output，mobile和desktop的输出文件都将在一个目录下。我希望的目录结构是各自资源位于各自的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public/</span><br><span class="line">  mobile/</span><br><span class="line">    bundle.js</span><br><span class="line">    css/</span><br><span class="line">    fonts/</span><br><span class="line">  desktop/</span><br><span class="line">    bundle.js</span><br><span class="line">    css/</span><br><span class="line">    fonts/</span><br></pre></td></tr></table></figure></p><p>终上，保持目录和配置清晰，最后采用导出多个配置对象进行构建<br>webpack.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [&#123;</span><br><span class="line">    name: <span class="string">'mobile'</span>,</span><br><span class="line">    entry: <span class="string">'src/mobile/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(process.cwd(), <span class="string">`./public/mobile/`</span>),</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        publicPath: <span class="string">'/mobile'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">'@'</span>: path.join(__dirname, <span class="string">'src/mobile'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    name: <span class="string">'desktop'</span>,</span><br><span class="line">    entry: <span class="string">'src/desktop/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(process.cwd(), <span class="string">`./public/desktop/`</span>),</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        publicPath: <span class="string">'/desktop'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">'@'</span>: path.join(__dirname, <span class="string">'src/desktop'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>现在，还没有配置热加载的机制。与之前导出单个配置对象并没有大的区别。不同的只是各个构建目标需要指定各自的<strong><em>path</em></strong>,<strong><em>name</em></strong>选项<br>webpack.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [&#123;</span><br><span class="line">...</span><br><span class="line">    entry: [<span class="string">'webpack-hot-middleware/client?path=/__webpack_hmr_mobile&amp;timeout=20000&amp;name=mobile'</span>, <span class="string">'src/mobile/index.js'</span>],</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">      <span class="keyword">new</span> webpack.NamedModulesPlugin()</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    ...</span><br><span class="line">    entry: [<span class="string">'webpack-hot-middleware/client?path=/__webpack_hmr_desktop&amp;timeout=20000&amp;name=desktop'</span>, <span class="string">'src/desktop/index.js'</span>],</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">      <span class="keyword">new</span> webpack.NamedModulesPlugin()</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>然后对每一个构建目标都需要添加一层中间件进行处理<br>server.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> configs = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"><span class="keyword">const</span> mobileCompiler = webpack(config[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">const</span> desktopCompiler = webpack(config[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理mobile的中间件</span></span><br><span class="line">app.use(webpackDevMiddleware(mobileCompiler, &#123;</span><br><span class="line">  publicPath: config[<span class="number">0</span>].output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line">app.use(webpackHotMiddleware(mobileCompiler, &#123;</span><br><span class="line">  path: <span class="string">'/__webpack_hmr_mobile'</span>,</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理desktop的中间件</span></span><br><span class="line">app.use(webpackDevMiddleware(mobileCompiler, &#123;</span><br><span class="line">  publicPath: config[<span class="number">1</span>].output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line">app.use(webpackHotMiddleware(mobileCompiler, &#123;</span><br><span class="line">  path: <span class="string">'/__webpack_hmr_desktop'</span>,</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!\n'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>现在，一切都变得索然无味！（：完成了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PC浏览器UserAgent总结</title>
      <link href="/2018/10/24/PC%E6%B5%8F%E8%A7%88%E5%99%A8UserAgent%E6%80%BB%E7%BB%93/"/>
      <url>/2018/10/24/PC%E6%B5%8F%E8%A7%88%E5%99%A8UserAgent%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>规范中定义了用户代理字符串用于应用程序标识自身。由软件名和版本组成，也允许列出应用程序主要部分的子产品，由<strong><em>空格</em></strong>分割<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">产品/版本号 子产品/版本号 子产品/版本号</span><br></pre></td></tr></table></figure></p><p>虽然规范定义的很简单，但是实际情况可不是。浏览器会在用户代理字符串中增添其他信息，如语言，平台，加密类型等，这些信息大部分会写在括号内，由<strong><em>分号</em></strong>分割（有的浏览器也会补充些其他信息，有的写在括号内有的写在括号外，反正就是很混乱）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36</span><br></pre></td></tr></table></figure></p><ul><li>加密类型 加密技术的类型：U表示128位（为U时有些浏览器会直接省略不写），I表示40位，N表示未加密</li><li>语言 浏览器设计时针对的目标用户语言</li><li>平台，操作系统或CPU<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Windows系统下：</span><br><span class="line">Windows NT 5.0 // 如 Windows 2000 </span><br><span class="line">Windows NT 5.1 // 如 Windows XP</span><br><span class="line">Windows NT 6.0 // 如 Windows Vista </span><br><span class="line">Windows NT 6.1 // 如 Windows 7</span><br><span class="line">Windows NT 6.2 // 如 Windows 8</span><br><span class="line">Windows NT 6.3 // 如 Windows 8.1</span><br><span class="line">Windows NT 10.0 // 如 Windows 10</span><br><span class="line">Win64; x64 // Win64 on x64</span><br><span class="line">WOW64 // Win32 on x64</span><br><span class="line"></span><br><span class="line">Linux系统下：</span><br><span class="line">X11; Linux i686; // Linux 桌面，i686 版本</span><br><span class="line">X11; Linux x86_64; // Linux 桌面，x86_64 版本</span><br><span class="line">X11; Linux i686 on x86_64 // Linux 桌面，运行在 x86_64 的 i686 版本</span><br><span class="line"></span><br><span class="line">macOS系统下：</span><br><span class="line">Macintosh; Intel Mac OS X 10_9_0 // Intel x86 或者 x86_64</span><br><span class="line">Macintosh; PPC Mac OS X 10_9_0 // PowerPC</span><br><span class="line">Macintosh; Intel Mac OS X 10.12; // 不用下划线，用点</span><br></pre></td></tr></table></figure></li></ul><h3 id="为什么UserAgent中总有Mozilla字样"><a href="#为什么UserAgent中总有Mozilla字样" class="headerlink" title="为什么UserAgent中总有Mozilla字样"></a>为什么UserAgent中总有Mozilla字样</h3><h3 id="浏览器UA的几个变化"><a href="#浏览器UA的几个变化" class="headerlink" title="浏览器UA的几个变化"></a>浏览器UA的几个变化</h3><ul><li><p>PC端Opera15后识别版本的关键字由<strong><em>Opera</em></strong>改为<strong><em>OPR</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Opera/9.80 (Macintosh; Intel Mac OS X 10.10.5) Presto/2.12.388 Version/12.16</span><br><span class="line">Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36 OPR/42.0.2393.94</span><br></pre></td></tr></table></figure></li><li><p>IE11后移除了<strong><em>compatible</em></strong>和<strong><em>MESI</em></strong>关键字，增加了<strong><em>rv:</em></strong>和<strong><em>like Gecko</em></strong>关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729)</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; SE 2.X MetaSr 1.0; rv:11.0) like Gecko</span><br></pre></td></tr></table></figure></li></ul><h3 id="国产浏览器极速模式与兼容模式"><a href="#国产浏览器极速模式与兼容模式" class="headerlink" title="国产浏览器极速模式与兼容模式"></a>国产浏览器极速模式与兼容模式</h3><p>一般情况下不需要识别具体用的是360还是QQ浏览器，只要能识别使用的是Chrome内核还是IE内核即可。兼容模式和极速模式下的UA不同，可通过UA判断当前使用的是哪种模式，唤起的开发者工具也不同。</p><p>部分国产浏览器实际UA测试如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">360_latest(360_10)</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36 QIHU 360SE</span><br><span class="line">    兼容：Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; rv:11.0) like Gecko</span><br><span class="line">360_9</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36</span><br><span class="line">    兼容：Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)</span><br><span class="line">2345_latest(2345_9)</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.90 Safari/537.36 2345Explorer/9.4.3.17934</span><br><span class="line">    兼容：Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; rv:11.0) like Gecko</span><br><span class="line">2345_8</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.108 Safari/537.36 2345Explorer/8.6.2.15784</span><br><span class="line">    兼容：Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; rv:11.0) like Gecko</span><br><span class="line">         Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729)</span><br><span class="line">sougou_latest(sougou_8)</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0</span><br><span class="line">    兼容：Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; SE 2.X MetaSr 1.0; rv:11.0) like Gecko</span><br><span class="line">qq_9</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.124 Safari/537.36 QQBrowser/9.0.2315.400</span><br><span class="line">    兼容：无法唤起开发者工具</span><br><span class="line">liebao_latest(liebao_6)</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36 LBBROWSER</span><br><span class="line">    兼容：无法唤起开发者工具</span><br></pre></td></tr></table></figure></p><p>在线查询浏览器UA工具：<a href="https://developers.whatismybrowser.com/useragents/explore/" target="_blank" rel="noopener">List of User Agents</a></p><h3 id="UA判断流程"><a href="#UA判断流程" class="headerlink" title="UA判断流程"></a>UA判断流程</h3><ol><li>根据<strong><em>OPR</em></strong>或<strong><em>Opera</em></strong>判断Opera并获取版本。只有Opera内核有<strong><em>OPR</em></strong>或<strong><em>Opera</em></strong>关键字</li><li>根据<strong><em>Firefox</em></strong>判断Firefox并获取版本。只有Firefox内核有<strong><em>Firefox</em></strong>关键字</li><li>根据<strong><em>MSIE</em></strong>判断IE&lt;=10并获取版本。只有IE 10及以下有<strong><em>MSIE</em></strong>关键字</li><li>根据<strong><em>Edge</em></strong>判断Edge并获取版本。只有Edge浏览器有<strong><em>Edge</em></strong>关键字，用的是trident渲染引擎</li><li>根据<strong><em>Chrome</em></strong>判断Chrome并获取版本。IE，Safari没有<strong><em>Chrome</em></strong>，所以有<strong><em>Chrome</em></strong>关键字的一定是Chrome内核</li><li>根据<strong><em>Safari</em></strong>判断Safari并获取版本。IE没有<strong><em>Safari</em></strong>关键字</li><li>根据<strong><em>rv:</em></strong>判断IE11并获取版本。剩下的就是IE 11及以上</li></ol><h6 id="顺序关键"><a href="#顺序关键" class="headerlink" title="顺序关键"></a>顺序关键</h6><p>Opera，Firefox，IE&lt;=10，Edge判断顺序不要求<br>Chrome，Safari在Opera，Firefox，IE，Edge之后判断，Safari在Chrome之后判断<br>IE&gt;=11最后判断</p><h6 id="判断代码"><a href="#判断代码" class="headerlink" title="判断代码"></a>判断代码</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> browser = <span class="string">''</span></span><br><span class="line"><span class="keyword">let</span> browserVersion = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> userAgent = navigator.userAgent</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (userAgent.indexOf(<span class="string">'OPR'</span>) &gt; <span class="number">-1</span> || userAgent.indexOf(<span class="string">'Opera'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'Opera'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/(Opera|OPR)[/?\s](\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">2</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">'Firefox'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'Firefox'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/Firefox[/\s](\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">'MSIE'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'IE'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/MSIE (\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">'Edge'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'Edge'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/Edge[/\s](\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">'Chrome'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'Chrome'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/Chrome[/\s](\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">'Safari'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'Safari'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/Version[/\s](\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">'rv:'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'IE'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/rv:(\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> UserAgent </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一只叫科学的狗</title>
      <link href="/2018/10/20/%E4%B8%80%E5%8F%AA%E5%8F%AB%E7%A7%91%E5%AD%A6%E7%9A%84%E7%8B%97/"/>
      <url>/2018/10/20/%E4%B8%80%E5%8F%AA%E5%8F%AB%E7%A7%91%E5%AD%A6%E7%9A%84%E7%8B%97/</url>
      
        <content type="html"><![CDATA[<p>想养一只叫科学的狗，猫也成。<br>说实在的，更喜欢猫，但又有点惧怕猫的的爪子和它的声音。时常脑补自己要是一不小心惹到猫主子，它一个伸手，我就得留上几道疤。猫的叫声也让我不舒服，尖声细腻。一个夜黑风高的晚上，漆黑的阁楼，不知哪传来声声的“喵，喵”叫，瘆人得很。<br>本着，开始一个项目前先得有个好名字的原则，我纠结着该给我的博客起个什么名字纠结了很久。程序员们常常会用星系，公司，科学家等各种牛逼极了的名字作为项目代号，Wellsfargo，Mercury，Newton……可是我这博客，我估摸着写不出什么牛逼的内容，思来想去的就只好以我未来的狗之名暂且作罢了。</p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
