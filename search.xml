<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Javascript执行之大揭秘——这一次做到心中有数</title>
      <link href="/2018/12/08/Javascript%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%E2%80%94%E2%80%94%E8%BF%99%E4%B8%80%E6%AC%A1%E5%81%9A%E5%88%B0%E5%BF%83%E4%B8%AD%E6%9C%89%E6%95%B0/"/>
      <url>/2018/12/08/Javascript%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%E2%80%94%E2%80%94%E8%BF%99%E4%B8%80%E6%AC%A1%E5%81%9A%E5%88%B0%E5%BF%83%E4%B8%AD%E6%9C%89%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="单线程执行"><a href="#单线程执行" class="headerlink" title="单线程执行"></a>单线程执行</h1><p>Javascript语言本身来说没有单线程的概念和机制，单线程指的是Javascript程序的执行是单线程的</p><p>执行环境如浏览器，Node等，它们的环境中带有JavaScript引擎，是专门处理JavaScript脚本的虚拟机。Javascript程序跑在引擎之上，且引擎以单线程的方式执行Javascript程序。<br><small>多线程需要共享资源，对最开始设计之初只是用来处理简单任务的网页脚本语言来说太复杂了，可能因此才会设计为单线程执行</small></p><p>而浏览器，Node等本身是多线程执行的，因为除了Javascript引擎外，还有其他的线程在工作，包括界面渲染线程，浏览器事件触发线程，Http请求线程</p><p><strong>除开H5引入的Web Worker来说，以上的描述没有问题。但是Web Worker的出现，允许我们在主线程之外开一些工作线程来处理耗时任务</strong></p><h1 id="认识异步模式"><a href="#认识异步模式" class="headerlink" title="认识异步模式"></a>认识异步模式</h1><p>运行以后的程序叫做进程，一般情况下一个进程一次只能执行一个任务。程序可能会有很多的任务需要处理，这时有3种处理方式选择<br><blockquote><ol><li>排队。因为一个进程一次只能执行一个任务，只好等前面的任务执行完了，再执行后面的任务</li><li>新建进程。使用fork命令，为每个任务新建一个进程。</li><li>新建线程。因为进程太耗费资源，所以如今的程序往往允许一个进程包含多个线程，由线程去完成任务</li></ol><footer><strong>http://www.ruanyifeng.com/blog/2013/10/event_loop.html</strong></footer></blockquote></p><p>因为JavaScript程序是单线程执行的，所有任务都在一个线程上完成，所有任务都是排队处理，一旦遇到大量任务或一个耗时的任务，网页就会出现“假死”，无法响应用户行为。这种排队处理的运行方式也叫“同步模式”或”堵塞模式“<br><img src="http://www.ruanyifeng.com/blogimg/asset/201310/2013102002.png"><br>特别是像I/O操作这种，是很耗时的，花费了大量的时间花在等待中。因此，如果能在I/O等指令发送之后继续执行队列中的后面任务，等I/O完成后再回过头来处理该I/O的响应，如此就能节省大量资源和执行时间<br><img src="http://www.ruanyifeng.com/blogimg/asset/201310/2013102004.png" alt=""><br>这种运行方式称为”异步模式”或”非堵塞模式”</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>图示（转自<a href="https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec" target="_blank" rel="noopener">《Understanding Javascript Function Executions — Call Stack, Event Loop , Tasks &amp; more》</a>）</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*-MMBHKy_ZxCrouecRqvsBg.png" alt=""></p><p>理解这张图需要先理解以下几个概念，由于每个概念深入下去又有很多可以讨论的问题，这里只简单介绍一下</p><h2 id="执行上下文-Execution-Context"><a href="#执行上下文-Execution-Context" class="headerlink" title="执行上下文(Execution Context)"></a>执行上下文(Execution Context)</h2><p>理解为代码运行时的环境，环境意味着当前能访问到哪些变量，哪些函数，this指向等，是一个抽象概念</p><p>三种执行上下文</p><ul><li>全局执行上下文。默认的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li>函数执行上下文。每当一个函数被调用时, 都会为该函数创建一个新的上下文。</li><li>Eval函数执行上下文。在Eval 函数内部执行的代码有属于它自己的执行上下文。</li></ul><p>创建执行上下文的细节</p><ol><li>创建阶段<ol><li>求this的值。由如何调用决定</li><li>创建词法环境组件 （构建作用域链；存储ES6中使用let, const声明的变量和声明式的函数）</li><li>创建变量环境组件（存储使用var声明的变量。可以简单认为是变量对象）</li></ol></li><li>执行阶段<br> 解释/执行代码。执行到每一行变量声明的位置时，才真正的对改变量进行赋值<br> <strong>注意：创建阶段变量（不包括声明式的函数，函数存在声明提升）并没有赋值，let, const声明的变量赋值前使用会报错，var声明的变量会返回undefined</strong></li></ol><p>变量对象（VO），活动对象（AO）<br>活动对象其实就是被激活的变量对象。每进入一个执行上下文时，这个执行上下文儿中的变量对象就被激活</p><h2 id="函数调用栈-Call-Stack"><a href="#函数调用栈-Call-Stack" class="headerlink" title="函数调用栈(Call Stack)"></a>函数调用栈(Call Stack)</h2><p>调用栈其实是一种解析器去处理程序的机制，能根据它追踪方法的调用和状态。上图的stack就是调用栈。栈这种数据结构的特点就是：后进先出</p><ol><li>栈底永远是全局执行上下文，栈顶就是当前正在执行的上下文</li><li>一个函数被调用的时候会将该函数的执行上下文推入栈顶</li><li>任何被这个函数调用的函数会进一步添加到调用栈中，执行结束后退出调用栈，程序运行到它们被上个函数调用的位置</li><li>当执行完这个函数后，它也从调用栈中推出，程序运行到它自己被上个函数调用的位置</li></ol><p><img src="https://img.ctolib.com/uploadImg/20170926/20170926143645_214.jpg" alt=""></p><p style="text-align: center; font-size: 0.7em;">示意图少了栈底全局执行上下文</p><p><small>其实栈中维护的是<a href="https://juejin.im/post/5b1560afe51d4506a74d2aeb" target="_blank" rel="noopener">栈帧</a>，栈帧中才维护了函数调用的上下文以及函数的返回地址，参数，局部变量等内容</small></p><h2 id="堆（Heap"><a href="#堆（Heap" class="headerlink" title="堆（Heap)"></a>堆（Heap)</h2><p>以堆的数据结构形式来存储数据的内存空间。上一节知道，调用栈中的每一帧中也维护了变量，参数，所以栈也是能存储一些数据。区别在于：<br>数据结构不同：<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D" target="_blank" rel="noopener">堆结构</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">栈结构</a><br>主要用途不同：堆主要用来存放对象的，栈主要用来执行程序以及存储一些简单类型的数据</p><ul><li>基本类型 （Undefined、Null、Boolean、Number和String）<br>  基本类型在内存中占据空间小、大小固定 ，他们的值保存在栈(stack)空间，是按值来访问</li><li>引用类型 （对象、数组、函数）<br>  引用类型占据空间大、大小不固定, 栈内存中存放地址指向堆(heap)内存中的对象。是按引用访问的</li></ul><p><img src="https://files.jb51.net/file_images/article/201805/2018527838001.png" alt=""></p><h2 id="任务队列-Call-Queue"><a href="#任务队列-Call-Queue" class="headerlink" title="任务队列(Call Queue)"></a>任务队列(Call Queue)</h2><p>异步任务的回调函数会进入任务队列之中。一旦调用栈中的任务执行完成后，就会去执行任务队列之中的任务</p><p>对DOM的操作有同步与异步之分<br>调用setAttribute，设置style等是在同步执行的，因此在使用这些方法，会导致重排重绘<br>交互产生的事件或addEventListener触发的事件是异步的，浏览器会将回调函数注册到任务队列之中</p><p>不只一个任务队列<br>不同任务源的回调函数会被放进不同的任务队列里面。DOM事件的回调函数进入DOM的任务队列，setTimeout的回调函数被进入setTimeout的任务队列之中，Promise的回调函数（传给then, catch的方法）进入Promise的任务队列等</p><p><strong>注意：Promise的第一个参数是不会进Promise的任务队列的，而是直接进调用栈执行</strong></p><p>其中setTimeout, setInterval的任务队列中的任务叫做macro-task(宏任务)，Promise的任务队列中的任务叫micro-task(微任务)。具体分为</p><ul><li>macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate(Node API), I/O, UI rendering</li><li>micro-task包括：process.nextTick(Node API), 原生Promise, Object.observe, MutationObserver</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果已经了解了以上所介绍的这些铺垫，那么事件循环的机制已经呼之欲出了</p><p>事件循环的顺序是从script开始第一次循环，随后全局上下文进入函数调用栈，碰到macro-task就将其交给处理它的模块处理完之后将回调函数放进macro-task的队列之中，碰到micro-task也是将其回调函数放进micro-task的队列之中。直到函数调用栈清空只剩全局执行上下文，然后开始执行所有的micro-task。当所有可执行的micro-task执行完毕之后。执行macro-task中的一个任务队列，执行完之后再执行所有的micro-task，就这样一直循环。</p><p><small>代码都要在调用栈执行。上图中指定的WEB APIS，无论是它本身还是它的回调函数都要进调用栈执行</small></p><p>两个具体的例子<br><a href="https://zhuanlan.zhihu.com/p/26229293" target="_blank" rel="noopener">深入浅出Javascript事件循环机制(上)</a><br><a href="https://zhuanlan.zhihu.com/p/26238030" target="_blank" rel="noopener">深入浅出JavaScript事件循环机制(下)</a></p><p>其他参考资料<br><a href="https://www.zhihu.com/question/35905242" target="_blank" rel="noopener">javascript既然是单线程语言 ， 为什么会分主线程和消息线程(event loop) ?</a><br><a href="https://juejin.im/post/5ba32171f265da0ab719a6d7" target="_blank" rel="noopener">[译] 理解 JavaScript 中的执行上下文和执行栈</a><br><a href="https://segmentfault.com/a/1190000009041008" target="_blank" rel="noopener">深入理解JavaScript执行上下文、函数堆栈、提升的概念</a><br><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html" target="_blank" rel="noopener">什么是 Event Loop？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 单线程 </tag>
            
            <tag> 事件循环 </tag>
            
            <tag> 执行上下文 </tag>
            
            <tag> 调用栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一只叫科学的狗</title>
      <link href="/2018/11/10/%E4%B8%80%E5%8F%AA%E5%8F%AB%E7%A7%91%E5%AD%A6%E7%9A%84%E7%8B%97/"/>
      <url>/2018/11/10/%E4%B8%80%E5%8F%AA%E5%8F%AB%E7%A7%91%E5%AD%A6%E7%9A%84%E7%8B%97/</url>
      
        <content type="html"><![CDATA[<p>想养一只叫科学的狗，猫也成。<br>说实在的，更喜欢猫，但又有点惧怕猫的的爪子和它的声音。时常脑补自己要是一不小心惹到猫主子，它一个伸手，我就得留上几道疤。猫的叫声也让我不舒服，尖声细腻。一个夜黑风高的晚上，漆黑的阁楼，不知哪传来声声的“喵，喵”叫，瘆人得很。<br>本着，开始一个项目前先得有个好名字的原则，我纠结着该给我的博客起个什么名字纠结了很久。程序员们常常会用星系，公司，科学家等各种牛逼极了的名字作为项目代号，Wellsfargo，Mercury，Newton……可是我这博客，我估摸着写不出什么牛逼的内容，思来想去的就只好以我未来的狗之名暂且作罢了。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Webpack HMR</title>
      <link href="/2018/11/10/Webpack-HMR/"/>
      <url>/2018/11/10/Webpack-HMR/</url>
      
        <content type="html"><![CDATA[<p>早些项目用的是Webpack1，配合webpack-dev-server，还算简单的配置就可实现热加载。这次接手的项目用了Webpack2，以及有两点不同导致配置更加复杂</p><ul><li>项目有自己的Node服务所以没有通过webpack-dev-server另起静态服务器</li><li>多个构建目标</li></ul><p>Webpack的配置实在让人头大（其实还是自己没有熟读文档），尤其是热加载这块。针对这次的项目做一个总结</p><h3 id="热刷新与热加载"><a href="#热刷新与热加载" class="headerlink" title="热刷新与热加载"></a>热刷新与热加载</h3><blockquote><ul><li>热刷新：文件改动后，整个页面刷新，不保留任何状态（比如输入过内容的Input表单），相当于webpack帮你摁了F5刷新</li><li>热加载：文件改动后，以最小的代价改变被改变的区域。尽可能保留改动文件前的状态（对input输入内容后，修改其他标签的代码）。即HMR</li></ul></blockquote><h3 id="编译代码的方式"><a href="#编译代码的方式" class="headerlink" title="编译代码的方式"></a>编译代码的方式</h3><p>开发时，要将原始代码编译为在浏览器中可执行的代码，最原始的，每一次改动后，人肉执行编译命令生成新文件。但是，大清都忘了多少年，这种方式效率太低了，无脑重复的事就应该交给机器去做。Webpack提供3种编译的方案选择，提高开发阶段的工作效率</p><h4 id="webpack’s-Watch-Mode"><a href="#webpack’s-Watch-Mode" class="headerlink" title="webpack’s Watch Mode"></a>webpack’s Watch Mode</h4><p>观察模式。如果其中一个文件被更新，代码将被重新编译，所以你不必手动运行整个构建。但是你还是需要手动刷新浏览器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --watch</span><br></pre></td></tr></table></figure></p><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>提供了一个简单的web服务器。文件改动后，web服务器就会自动重新加载编译后的代码，省掉了手动刷新浏览器这一步。同时支持热刷新和热加载<br>简单的使用，只需要在webpack配置文件中添加devServer一节<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">entry: &#123;</span><br><span class="line">  app: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 告诉 webpack-dev-server，在 localhost:8080 下建立服务</span></span><br><span class="line">devServer: &#123;</span><br><span class="line">  <span class="comment">// 服务的根目录在dist 目录下</span></span><br><span class="line">  contentBase: <span class="string">'./dist'</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="webpack-dev-middleware"><a href="#webpack-dev-middleware" class="headerlink" title="webpack-dev-middleware"></a>webpack-dev-middleware</h4><p>中间件。它可以把<strong><em>webpack处理后的文件传递给一个服务器(server)</em></strong>。 webpack-dev-server 在内部使用了它，同时，它也可以作为一个单独的包来使用，以便进行更多自定义设置来实现更多的需求。比如你有一个自己的Node服务<br>webpack.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">entry: &#123;</span><br><span class="line">  app: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  publicPath: <span class="string">'/'</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>server.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config);</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  <span class="comment">// 如何访问编译后的静态资源</span></span><br><span class="line">  <span class="comment">// 如果配置为'/'，则表示资源在http://localhost:3000 下访问。注意，是在当前Node服务的端口之下</span></span><br><span class="line">  publicPath: config.output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!\n'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="启用HMR"><a href="#启用HMR" class="headerlink" title="启用HMR"></a>启用HMR</h3><p>上面的编译方式中第二，三种方式都支持热刷新和热加载。启用热加载还需要多做一些工作</p><h4 id="webpack-dev-server-1"><a href="#webpack-dev-server-1" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>修改webpack配置文件devServer一节中的配置，再配合使用webpack内置的HMR插件即可<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">entry: &#123;</span><br><span class="line">  app: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 告诉 webpack-dev-server，在 localhost:8080 下建立服务</span></span><br><span class="line">devServer: &#123;</span><br><span class="line">  <span class="comment">// 服务的根目录在dist 目录下</span></span><br><span class="line">  contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">  <span class="comment">// 启用webpack的模块热替换特性</span></span><br><span class="line">  hot: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 使用HotModuleReplacementPlugin后才能完全启用HMR</span></span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  <span class="comment">// 可选。当接收到热更新信号时，在浏览器console控制台打印更多可读性高的模块名称等信息</span></span><br><span class="line">  <span class="keyword">new</span> webpack.NamedModulesPlugin()</span><br><span class="line">],</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><blockquote><p>注意，必须有 webpack.HotModuleReplacementPlugin 才能完全启用 HMR。如果 webpack 或 webpack-dev-server 是通过 –hot 选项启动的，那么这个插件会被自动添加，所以你可能不需要把它添加到 webpack.config.js 中。</p><footer><strong>@webpack</strong><cite><a href="https://webpack.docschina.org/configuration/dev-server/#devserver-hot" target="_blank" rel="noopener">webpack.docschina.org/configuration/dev-server/#devserver-hot</a></cite></footer></blockquote><p>修改入口文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 HotModuleReplacementPlugin 启用了HMR后，它的接口将被暴露在 module.hot 属性下面。需要先要检查这个接口是否可访问，然后再开始使用它。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="comment">// 指定的依赖模块发生改变时进行更新，更新完成后触发回调</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./print.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Accepting the updated printMe module!'</span>);</span><br><span class="line">    printMe();</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 或者也可以</span></span><br><span class="line">  <span class="comment">// 接受自身更新。当前模块或依赖模块发生改变时进行更新</span></span><br><span class="line">  <span class="comment">// 在入口文件中添加，则意味对所有模块的修改都能监听到并进行更新</span></span><br><span class="line">  <span class="comment">// module.hot.accept(</span></span><br><span class="line">  <span class="comment">//   errorHandler // 更新异常时触发错误回调</span></span><br><span class="line">  <span class="comment">// );</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://webpack.docschina.org/guides/hot-module-replacement#%E5%90%AF%E7%94%A8-hmr" target="_blank" rel="noopener">完整的官方示例</a></p><p>上面是通过配置的方式使用webpack-dev-server，其实也可以通过webpack-dev-server提供的<a href="https://webpack.docschina.org/guides/hot-module-replacement#%E9%80%9A%E8%BF%87-node-js-api" target="_blank" rel="noopener">Node.js API</a>方式使用<br>注意，它与下面的webpack-dev-middleware不是一回事，虽然都有一个自己的Node服务，但是webpack-dev-server会另起一个静态文件服务（内部也调用了webpack-dev-middleware），而webpack-dev-middleware则以中间件的形式将处理结果通知给自己的Node服务</p><h4 id="webpack-dev-middleware-1"><a href="#webpack-dev-middleware-1" class="headerlink" title="webpack-dev-middleware"></a>webpack-dev-middleware</h4><p>配合<a href="https://github.com/webpack-contrib/webpack-hot-middleware" target="_blank" rel="noopener">webpack-hot-middleware</a>才能在自己的服务下启用 HMR<br>webpack.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">entry: &#123;</span><br><span class="line">  app: [</span><br><span class="line">    <span class="comment">// 用于连接后台服务，接受后台服务修改编译文件后的通知</span></span><br><span class="line">    <span class="comment">// 通过查询字符串传递参数</span></span><br><span class="line">    <span class="string">'webpack-hot-middleware/client'</span>,</span><br><span class="line">    <span class="string">'./src/index.js'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  publicPath: <span class="string">'/'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 不再需要devServer一节</span></span><br><span class="line">plugins: [</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 仍然需要使用HotModuleReplacementPlugin</span></span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  <span class="keyword">new</span> webpack.NamedModulesPlugin()</span><br><span class="line">],</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>server.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackHotMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config);</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  publicPath: config.output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// 加入webpack-hot-middleware中间件</span></span><br><span class="line"><span class="comment">// 可传入webpack-hot-middleware的配置项作为第二个参数</span></span><br><span class="line">app.use(webpackHotMiddleware(compiler));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!\n'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>入口文件也需要调用module.hot.accept，webpack-dev-server方式一模一样。略去</p><p>传给客户端的配置。可以通过查询字符串的方式传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-hot-middleware/client?noInfo=true&amp;path=/__webpack_hmr__</span><br></pre></td></tr></table></figure></p><ul><li>path - 中间件为事件流提供的路径。相当于消息是通过这个地址从后台传给客户端的</li><li>name - 捆绑名称，专门用于多编译器模式。2.13.0之前不支持多编译器模式</li><li>timeout - 尝试重新连接后断开连接后等待的时间</li><li>reload - 设置为true在Webpack卡住时自动重新加载页面</li><li>noInfo - 设置为true禁用信息（Info级别的日志？）控制台日志记录</li><li>quiet - 设置为true禁用所有控制台日志记录</li><li>dynamicPublicPath</li><li>autoConnect</li></ul><p>传给中间件的配置。通过传递第二个参数传递<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">webpackHotMiddleware(compiler, &#123;</span><br><span class="line">  log: <span class="literal">false</span>,</span><br><span class="line">  path: <span class="string">"/__webpack_hmr__"</span>,</span><br><span class="line">  heartbeat: <span class="number">2000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>log - 用于记录行的函数，传递false到禁用。默认为console.log</li><li>path - 中间件服务的事件流的路径必须与客户端设置相匹配</li><li>heartbeat - 多长时间将心跳更新发送到客户端以保持连接的活动。应小于客户的timeout设置 - - 通常设置为其一半值</li></ul><h3 id="多个构建目标"><a href="#多个构建目标" class="headerlink" title="多个构建目标"></a>多个构建目标</h3><p>除了导出一个配置对象外，webpack.config.js也支持导出<a href="https://webpack.docschina.org/configuration/configuration-types" target="_blank" rel="noopener">函数，Promise, 多个配置对象</a></p><p>以我的实际情况为例，我接手的项目</p><ul><li>会启动一个node服务</li><li>同时有移动端和桌面端的代码</li><li>静态文件服务的根目录为public/，构建后输出文件都在public/之下</li><li>使用webpack-dev-middle实现热加载机制</li></ul><p>考虑单独构建mobile, desktop<br>调用不同的webpack配置文件或一个配置文件中通过环境变量控制当前构建哪一个。麻烦的点在于不能同时构建，如果正开发着移动端，突然要切换到桌面端则需要重启。代码里少不了到处判断当前构建目标是哪个了。有没有更简单的方式？</p><p>考虑使用多个entry的方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  mobile: <span class="string">'src/mobile/index.js'</span>,</span><br><span class="line">  desktop: <span class="string">'src/desktop/index.js'</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.join(__dirname, <span class="string">'public/'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'@'</span>: path.join(__dirname, <span class="string">'src'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>但是这样会有一个问题，mobile和desktop的源文件位于不同的目录之下，假设都用@作为别名指向src/目录并不太方便，import时还必须加上<strong><em>“@/mobile”</em></strong>,<strong><em>“@/desktop”</em></strong>，变通的方式是再找一个符号区别mobile和desktop<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  mobile: <span class="string">'src/mobile/index.js'</span>,</span><br><span class="line">  desktop: <span class="string">'src/desktop/index.js'</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.join(__dirname, <span class="string">'public/'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'@'</span>: path.join(__dirname, <span class="string">'src/desktop'</span>),</span><br><span class="line">    <span class="string">'_'</span>: path.join(__dirname, <span class="string">'src/mobile'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>不是不可以，只是项目已有一定规模，不希望重改。并且还有一个问题是，这种方式只能指定一个Output，mobile和desktop的输出文件都将在一个目录下。我希望的目录结构是各自资源位于各自的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public/</span><br><span class="line">  mobile/</span><br><span class="line">    bundle.js</span><br><span class="line">    css/</span><br><span class="line">    fonts/</span><br><span class="line">  desktop/</span><br><span class="line">    bundle.js</span><br><span class="line">    css/</span><br><span class="line">    fonts/</span><br></pre></td></tr></table></figure></p><p>终上，保持目录和配置清晰，最后采用导出多个配置对象进行构建<br>webpack.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [&#123;</span><br><span class="line">    name: <span class="string">'mobile'</span>,</span><br><span class="line">    entry: <span class="string">'src/mobile/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(process.cwd(), <span class="string">`./public/mobile/`</span>),</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        publicPath: <span class="string">'/mobile'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">'@'</span>: path.join(__dirname, <span class="string">'src/mobile'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    name: <span class="string">'desktop'</span>,</span><br><span class="line">    entry: <span class="string">'src/desktop/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(process.cwd(), <span class="string">`./public/desktop/`</span>),</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        publicPath: <span class="string">'/desktop'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">'@'</span>: path.join(__dirname, <span class="string">'src/desktop'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>现在，还没有配置热加载的机制。与之前导出单个配置对象并没有大的区别。不同的只是各个构建目标需要指定各自的<strong><em>path</em></strong>,<strong><em>name</em></strong>选项<br>webpack.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [&#123;</span><br><span class="line">...</span><br><span class="line">    entry: [<span class="string">'webpack-hot-middleware/client?path=/__webpack_hmr_mobile&amp;timeout=20000&amp;name=mobile'</span>, <span class="string">'src/mobile/index.js'</span>],</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">      <span class="keyword">new</span> webpack.NamedModulesPlugin()</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    ...</span><br><span class="line">    entry: [<span class="string">'webpack-hot-middleware/client?path=/__webpack_hmr_desktop&amp;timeout=20000&amp;name=desktop'</span>, <span class="string">'src/desktop/index.js'</span>],</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">      <span class="keyword">new</span> webpack.NamedModulesPlugin()</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>然后对每一个构建目标都需要添加一层中间件进行处理<br>server.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> configs = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"><span class="keyword">const</span> mobileCompiler = webpack(config[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">const</span> desktopCompiler = webpack(config[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理mobile的中间件</span></span><br><span class="line">app.use(webpackDevMiddleware(mobileCompiler, &#123;</span><br><span class="line">  publicPath: config[<span class="number">0</span>].output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line">app.use(webpackHotMiddleware(mobileCompiler, &#123;</span><br><span class="line">  path: <span class="string">'/__webpack_hmr_mobile'</span>,</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理desktop的中间件</span></span><br><span class="line">app.use(webpackDevMiddleware(mobileCompiler, &#123;</span><br><span class="line">  publicPath: config[<span class="number">1</span>].output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line">app.use(webpackHotMiddleware(mobileCompiler, &#123;</span><br><span class="line">  path: <span class="string">'/__webpack_hmr_desktop'</span>,</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!\n'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>现在，一切都变得索然无味！（：完成了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PC浏览器UserAgent总结</title>
      <link href="/2018/10/24/PC%E6%B5%8F%E8%A7%88%E5%99%A8UserAgent%E6%80%BB%E7%BB%93/"/>
      <url>/2018/10/24/PC%E6%B5%8F%E8%A7%88%E5%99%A8UserAgent%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>规范中定义了用户代理字符串用于应用程序标识自身。由软件名和版本组成，也允许列出应用程序主要部分的子产品，由<strong><em>空格</em></strong>分割<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">产品/版本号 子产品/版本号 子产品/版本号</span><br></pre></td></tr></table></figure></p><p>虽然规范定义的很简单，但是实际情况可不是。浏览器会在用户代理字符串中增添其他信息，如语言，平台，加密类型等，这些信息大部分会写在括号内，由<strong><em>分号</em></strong>分割（有的浏览器也会补充些其他信息，有的写在括号内有的写在括号外，反正就是很混乱）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36</span><br></pre></td></tr></table></figure></p><ul><li>加密类型 加密技术的类型：U表示128位（为U时有些浏览器会直接省略不写），I表示40位，N表示未加密</li><li>语言 浏览器设计时针对的目标用户语言</li><li>平台，操作系统或CPU<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Windows系统下：</span><br><span class="line">Windows NT 5.0 // 如 Windows 2000 </span><br><span class="line">Windows NT 5.1 // 如 Windows XP</span><br><span class="line">Windows NT 6.0 // 如 Windows Vista </span><br><span class="line">Windows NT 6.1 // 如 Windows 7</span><br><span class="line">Windows NT 6.2 // 如 Windows 8</span><br><span class="line">Windows NT 6.3 // 如 Windows 8.1</span><br><span class="line">Windows NT 10.0 // 如 Windows 10</span><br><span class="line">Win64; x64 // Win64 on x64</span><br><span class="line">WOW64 // Win32 on x64</span><br><span class="line"></span><br><span class="line">Linux系统下：</span><br><span class="line">X11; Linux i686; // Linux 桌面，i686 版本</span><br><span class="line">X11; Linux x86_64; // Linux 桌面，x86_64 版本</span><br><span class="line">X11; Linux i686 on x86_64 // Linux 桌面，运行在 x86_64 的 i686 版本</span><br><span class="line"></span><br><span class="line">macOS系统下：</span><br><span class="line">Macintosh; Intel Mac OS X 10_9_0 // Intel x86 或者 x86_64</span><br><span class="line">Macintosh; PPC Mac OS X 10_9_0 // PowerPC</span><br><span class="line">Macintosh; Intel Mac OS X 10.12; // 不用下划线，用点</span><br></pre></td></tr></table></figure></li></ul><h3 id="为什么UserAgent中总有Mozilla字样"><a href="#为什么UserAgent中总有Mozilla字样" class="headerlink" title="为什么UserAgent中总有Mozilla字样"></a>为什么UserAgent中总有Mozilla字样</h3><h3 id="浏览器UA的几个变化"><a href="#浏览器UA的几个变化" class="headerlink" title="浏览器UA的几个变化"></a>浏览器UA的几个变化</h3><ul><li><p>PC端Opera15后识别版本的关键字由<strong><em>Opera</em></strong>改为<strong><em>OPR</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Opera/9.80 (Macintosh; Intel Mac OS X 10.10.5) Presto/2.12.388 Version/12.16</span><br><span class="line">Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36 OPR/42.0.2393.94</span><br></pre></td></tr></table></figure></li><li><p>IE11后移除了<strong><em>compatible</em></strong>和<strong><em>MESI</em></strong>关键字，增加了<strong><em>rv:</em></strong>和<strong><em>like Gecko</em></strong>关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729)</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; SE 2.X MetaSr 1.0; rv:11.0) like Gecko</span><br></pre></td></tr></table></figure></li></ul><h3 id="国产浏览器极速模式与兼容模式"><a href="#国产浏览器极速模式与兼容模式" class="headerlink" title="国产浏览器极速模式与兼容模式"></a>国产浏览器极速模式与兼容模式</h3><p>一般情况下不需要识别具体用的是360还是QQ浏览器，只要能识别使用的是Chrome内核还是IE内核即可。兼容模式和极速模式下的UA不同，可通过UA判断当前使用的是哪种模式，唤起的开发者工具也不同。</p><p>部分国产浏览器实际UA测试如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">360_latest(360_10)</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36 QIHU 360SE</span><br><span class="line">    兼容：Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; rv:11.0) like Gecko</span><br><span class="line">360_9</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36</span><br><span class="line">    兼容：Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)</span><br><span class="line">2345_latest(2345_9)</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.90 Safari/537.36 2345Explorer/9.4.3.17934</span><br><span class="line">    兼容：Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; rv:11.0) like Gecko</span><br><span class="line">2345_8</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.108 Safari/537.36 2345Explorer/8.6.2.15784</span><br><span class="line">    兼容：Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; rv:11.0) like Gecko</span><br><span class="line">         Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729)</span><br><span class="line">sougou_latest(sougou_8)</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0</span><br><span class="line">    兼容：Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; SE 2.X MetaSr 1.0; rv:11.0) like Gecko</span><br><span class="line">qq_9</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.124 Safari/537.36 QQBrowser/9.0.2315.400</span><br><span class="line">    兼容：无法唤起开发者工具</span><br><span class="line">liebao_latest(liebao_6)</span><br><span class="line">    极速：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36 LBBROWSER</span><br><span class="line">    兼容：无法唤起开发者工具</span><br></pre></td></tr></table></figure></p><p>在线查询浏览器UA工具：<a href="https://developers.whatismybrowser.com/useragents/explore/" target="_blank" rel="noopener">List of User Agents</a></p><h3 id="UA判断流程"><a href="#UA判断流程" class="headerlink" title="UA判断流程"></a>UA判断流程</h3><ol><li>根据<strong><em>OPR</em></strong>或<strong><em>Opera</em></strong>判断Opera并获取版本。只有Opera内核有<strong><em>OPR</em></strong>或<strong><em>Opera</em></strong>关键字</li><li>根据<strong><em>Firefox</em></strong>判断Firefox并获取版本。只有Firefox内核有<strong><em>Firefox</em></strong>关键字</li><li>根据<strong><em>MSIE</em></strong>判断IE&lt;=10并获取版本。只有IE 10及以下有<strong><em>MSIE</em></strong>关键字</li><li>根据<strong><em>Edge</em></strong>判断Edge并获取版本。只有Edge浏览器有<strong><em>Edge</em></strong>关键字，用的是trident渲染引擎</li><li>根据<strong><em>Chrome</em></strong>判断Chrome并获取版本。IE，Safari没有<strong><em>Chrome</em></strong>，所以有<strong><em>Chrome</em></strong>关键字的一定是Chrome内核</li><li>根据<strong><em>Safari</em></strong>判断Safari并获取版本。IE没有<strong><em>Safari</em></strong>关键字</li><li>根据<strong><em>rv:</em></strong>判断IE11并获取版本。剩下的就是IE 11及以上</li></ol><h6 id="顺序关键"><a href="#顺序关键" class="headerlink" title="顺序关键"></a>顺序关键</h6><p>Opera，Firefox，IE&lt;=10，Edge判断顺序不要求<br>Chrome，Safari在Opera，Firefox，IE，Edge之后判断，Safari在Chrome之后判断<br>IE&gt;=11最后判断</p><h6 id="判断代码"><a href="#判断代码" class="headerlink" title="判断代码"></a>判断代码</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> browser = <span class="string">''</span></span><br><span class="line"><span class="keyword">let</span> browserVersion = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> userAgent = navigator.userAgent</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (userAgent.indexOf(<span class="string">'OPR'</span>) &gt; <span class="number">-1</span> || userAgent.indexOf(<span class="string">'Opera'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'Opera'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/(Opera|OPR)[/?\s](\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">2</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">'Firefox'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'Firefox'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/Firefox[/\s](\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">'MSIE'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'IE'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/MSIE (\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">'Edge'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'Edge'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/Edge[/\s](\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">'Chrome'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'Chrome'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/Chrome[/\s](\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">'Safari'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'Safari'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/Version[/\s](\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">'rv:'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  browser = <span class="string">'IE'</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="regexp">/rv:(\d+\.\d+)/</span>.exec(userAgent)</span><br><span class="line">  browserVersion = <span class="built_in">Number</span>(matches[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> UserAgent </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
